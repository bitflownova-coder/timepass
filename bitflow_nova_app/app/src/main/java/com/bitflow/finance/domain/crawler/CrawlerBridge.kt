package com.bitflow.finance.domain.crawler

import android.content.Context
import com.chaquo.python.Python
import com.chaquo.python.android.AndroidPlatform
import com.google.gson.Gson
import com.google.gson.annotations.SerializedName
import dagger.hilt.android.qualifiers.ApplicationContext
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.File
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Bridge between Kotlin and embedded Python crawler.
 * Uses Chaquopy to call Python functions.
 */
@Singleton
class CrawlerBridge @Inject constructor(
    @ApplicationContext private val context: Context
) {
    private val gson = Gson()
    
    // Lazy initialization of Python
    private val python: Python by lazy {
        if (!Python.isStarted()) {
            Python.start(AndroidPlatform(context))
        }
        Python.getInstance()
    }
    
    private val crawlerModule by lazy {
        python.getModule("crawler_engine")
    }
    
    // Output directory for crawl results
    private val outputDir: File
        get() = File(context.filesDir, "crawler_output").also { it.mkdirs() }
    
    /**
     * Start a new crawl with comprehensive analysis.
     * @param url The starting URL to crawl
     * @param depth Maximum crawl depth
     * @param userAgent User Agent string to use for requests
     * @param scanCategories Comma-separated list of scan categories or "all"
     * @return The crawl ID
     */
    suspend fun startCrawl(url: String, depth: Int, userAgent: String = "Mozilla/5.0", scanCategories: String = "all"): String = withContext(Dispatchers.IO) {
        val result = crawlerModule.callAttr("start_crawl", url, depth, outputDir.absolutePath, userAgent, scanCategories)
        result.toString()
    }
    
    /**
     * Get the status of a crawl with detailed progress.
     * @param crawlId The crawl ID
     * @return CrawlStatus object
     */
    suspend fun getStatus(crawlId: String): CrawlStatus = withContext(Dispatchers.IO) {
        val result = crawlerModule.callAttr("get_status", crawlId)
        val json = result.toString()
        try {
            gson.fromJson(json, CrawlStatus::class.java)
        } catch (e: Exception) {
            CrawlStatus(status = "error", error = e.message)
        }
    }
    
    /**
     * Get the full analysis report for a crawl.
     * @param crawlId The crawl ID
     * @return AnalysisReport object
     */
    suspend fun getAnalysisReport(crawlId: String): AnalysisReport = withContext(Dispatchers.IO) {
        val result = crawlerModule.callAttr("get_analysis_report", crawlId, outputDir.absolutePath)
        val json = result.toString()
        try {
            gson.fromJson(json, AnalysisReport::class.java)
        } catch (e: Exception) {
            AnalysisReport(error = e.message)
        }
    }
    
    /**
     * Stop a running crawl.
     * @param crawlId The crawl ID
     * @return True if stopped successfully
     */
    suspend fun stopCrawl(crawlId: String): Boolean = withContext(Dispatchers.IO) {
        val result = crawlerModule.callAttr("stop_crawl", crawlId)
        val json = result.toString()
        try {
            val response = gson.fromJson(json, StopResponse::class.java)
            response.success
        } catch (e: Exception) {
            false
        }
    }

    suspend fun generateSitemap(crawlId: String): String = withContext(Dispatchers.IO) {
        val result = crawlerModule.callAttr("generate_sitemap", crawlId)
        result.toString()
    }

    suspend fun exportData(crawlId: String, format: String): String = withContext(Dispatchers.IO) {
        val result = crawlerModule.callAttr("export_data", crawlId, format)
        result.toString()
    }
    
    suspend fun generatePdf(crawlId: String): String = withContext(Dispatchers.IO) {
        val result = crawlerModule.callAttr("generate_pdf_report", crawlId)
        result.toString()
    }
    
    /**
     * Get files generated by a crawl.
     * @param crawlId The crawl ID
     * @return CrawlFiles object containing lists of content, images, and documents
     */
    suspend fun getFiles(crawlId: String): CrawlFiles = withContext(Dispatchers.IO) {
        val result = crawlerModule.callAttr("get_files", crawlId, outputDir.absolutePath)
        val json = result.toString()
        try {
            gson.fromJson(json, CrawlFiles::class.java)
        } catch (e: Exception) {
            CrawlFiles()
        }
    }
    
    /**
     * Get the output directory path for a specific crawl.
     */
    fun getCrawlOutputDir(crawlId: String): File {
        return File(outputDir, crawlId)
    }
    
    /**
     * Read a content file.
     */
    suspend fun readContentFile(crawlId: String, filename: String): String = withContext(Dispatchers.IO) {
        try {
            val file = File(getCrawlOutputDir(crawlId), "content/$filename")
            if (file.exists()) file.readText() else ""
        } catch (e: Exception) {
            ""
        }
    }
    
    /**
     * Read an HTML source file.
     */
    suspend fun readHtmlFile(crawlId: String, filename: String): String = withContext(Dispatchers.IO) {
        try {
            val file = File(getCrawlOutputDir(crawlId), "html/$filename")
            if (file.exists()) file.readText() else ""
        } catch (e: Exception) {
            ""
        }
    }
}

/**
 * Data class representing crawl status from Python.
 */
data class CrawlStatus(
    val status: String = "unknown",
    val url: String? = null,
    val depth: Int? = null,
    @SerializedName("pages_crawled") val pagesCrawled: Int = 0,
    @SerializedName("pages_total") val pagesTotal: Int = 0,
    @SerializedName("pages_queued") val pagesQueued: Int = 0,
    @SerializedName("current_url") val currentUrl: String = "",
    val duration: Int = 0,
    val error: String? = null
) {
    val isRunning: Boolean
        get() = status == "running"
    
    val isCompleted: Boolean
        get() = status == "completed"
    
    val isFailed: Boolean
        get() = status == "failed" || status == "error"
    
    val progressPercent: Int
        get() = if (pagesTotal > 0) ((pagesCrawled.toFloat() / pagesTotal) * 100).toInt() else 0
}

/**
 * Data class for stop response.
 */
data class StopResponse(
    val success: Boolean = false,
    val error: String? = null
)

/**
 * Data class for crawl files.
 */
data class CrawlFiles(
    val content: List<String> = emptyList(),
    val images: List<String> = emptyList(),
    val documents: List<String> = emptyList(),
    val html: List<String> = emptyList(),
    val stylesheets: List<String> = emptyList(),
    val scripts: List<String> = emptyList()
) {
    val totalFiles: Int
        get() = content.size + images.size + documents.size + html.size + stylesheets.size + scripts.size
}

/**
 * Data class for full analysis report.
 */
data class AnalysisReport(
    val url: String? = null,
    @SerializedName("pages_crawled") val pagesCrawled: Int = 0,
    @SerializedName("hidden_paths") val hiddenPaths: List<HiddenPath> = emptyList(),
    val subdomains: List<SubdomainInfo> = emptyList(),
    val ssl: SslInfo? = null,
    @SerializedName("seo_issues") val seoIssues: List<PageIssue> = emptyList(),
    @SerializedName("security_issues") val securityIssues: List<PageIssue> = emptyList(),
    @SerializedName("all_pages") val allPages: List<PageInfo> = emptyList(),
    // NEW: Enhanced security findings
    @SerializedName("robots_analysis") val robotsAnalysis: RobotsAnalysis? = null,
    @SerializedName("waf_detection") val wafDetection: WafDetection? = null,
    @SerializedName("cors_findings") val corsFindings: CorsFindings? = null,
    @SerializedName("http_methods") val httpMethods: HttpMethodsResult? = null,
    @SerializedName("secrets_found") val secretsFound: List<SecretFinding> = emptyList(),
    @SerializedName("forms_found") val formsFound: List<FormInfo> = emptyList(),
    @SerializedName("cookies_found") val cookiesFound: List<CookieInfo> = emptyList(),
    @SerializedName("osint_summary") val osintSummary: OsintSummary? = null,
    val technologies: List<TechnologyInfo> = emptyList(),
    val vulnerabilities: List<Vulnerability> = emptyList(),
    @SerializedName("error_pages") val errorPages: ErrorPagesResult? = null,
    // NEW: Advanced security scan results
    @SerializedName("dns_recon") val dnsRecon: DnsReconResult? = null,
    @SerializedName("email_security") val emailSecurity: EmailSecurityResult? = null,
    @SerializedName("ssl_analysis") val sslAnalysis: SslAnalysisResult? = null,
    @SerializedName("subdomain_enum") val subdomainEnum: SubdomainEnumResult? = null,
    @SerializedName("api_discovery") val apiDiscovery: ApiDiscoveryResult? = null,
    @SerializedName("param_fuzzing") val paramFuzzing: ParamFuzzingResult? = null,
    @SerializedName("auth_testing") val authTesting: AuthTestingResult? = null,
    @SerializedName("cloud_scanner") val cloudScanner: CloudScannerResult? = null,
    @SerializedName("security_headers") val securityHeaders: SecurityHeadersResult? = null,
    // Security summary from Python
    @SerializedName("security_score") val securityScore: Int? = null,
    @SerializedName("security_grade") val securityGrade: String? = null,
    @SerializedName("critical_vulnerabilities") val criticalVulnCount: Int = 0,
    @SerializedName("high_vulnerabilities") val highVulnCount: Int = 0,
    @SerializedName("medium_vulnerabilities") val mediumVulnCount: Int = 0,
    @SerializedName("enabled_scans") val enabledScans: List<String> = emptyList(),
    val error: String? = null
) {
    // Calculate overall health score - use server-side if available
    val healthScore: Int
        get() {
            // Prefer server-calculated security score
            securityScore?.let { return it }
            
            // Fallback to client-side calculation
            var score = 100
            score -= (seoIssues.size * 2).coerceAtMost(30)
            score -= (securityIssues.size * 3).coerceAtMost(30)
            score -= (secretsFound.size * 10).coerceAtMost(20)
            score -= (vulnerabilities.count { it.severity == "Critical" } * 15).coerceAtMost(30)
            score -= (vulnerabilities.count { it.severity == "High" } * 10).coerceAtMost(20)
            if (ssl?.valid != true) score -= 20
            if (corsFindings?.vulnerable == true) score -= 15
            return score.coerceIn(0, 100)
        }
    
    val criticalVulnerabilities: Int
        get() = if (criticalVulnCount > 0) criticalVulnCount else vulnerabilities.count { it.severity == "Critical" }
    
    val highVulnerabilities: Int
        get() = if (highVulnCount > 0) highVulnCount else vulnerabilities.count { it.severity == "High" }
    
    val mediumVulnerabilities: Int
        get() = if (mediumVulnCount > 0) mediumVulnCount else vulnerabilities.count { it.severity == "Medium" }
}

data class HiddenPath(
    val url: String = "",
    val status: Int = 0,
    val path: String = ""
)

data class SslInfo(
    val url: String = "",
    @SerializedName("has_ssl") val hasSsl: Boolean = false,
    val valid: Boolean = false,
    val issuer: String? = null,
    val subject: String? = null,
    val expires: String? = null,
    val protocol: String? = null,
    val issues: List<String> = emptyList()
)

data class PageIssue(
    val url: String = "",
    val issue: String = ""
)

data class PageInfo(
    val url: String = "",
    val status: Int? = null,
    val success: Boolean = false,
    @SerializedName("load_time") val loadTime: Int? = null,
    val size: Int? = null
)

// NEW: Enhanced security data classes

data class SubdomainInfo(
    val url: String = "",
    val status: Int = 0,
    val type: String = ""
)

data class RobotsAnalysis(
    @SerializedName("robots_exists") val robotsExists: Boolean = false,
    @SerializedName("sitemap_urls") val sitemapUrls: List<String> = emptyList(),
    @SerializedName("disallowed_paths") val disallowedPaths: List<String> = emptyList(),
    @SerializedName("accessible_disallowed") val accessibleDisallowed: List<HiddenPath> = emptyList(),
    @SerializedName("crawl_delay") val crawlDelay: Int? = null
)

data class WafDetection(
    val detected: Boolean = false,
    val name: String? = null,
    val confidence: String = "",
    val indicators: List<String> = emptyList()
)

data class CorsFindings(
    val vulnerable: Boolean = false,
    val type: String? = null,
    val details: String? = null,
    @SerializedName("allowed_origin") val allowedOrigin: String? = null,
    @SerializedName("allows_credentials") val allowsCredentials: Boolean = false
)

data class HttpMethodsResult(
    @SerializedName("allowed_methods") val allowedMethods: List<String> = emptyList(),
    @SerializedName("dangerous_methods") val dangerousMethods: List<String> = emptyList()
)

data class SecretFinding(
    val type: String = "",
    val value: String = "",
    val file: String = "",
    @SerializedName("line_number") val lineNumber: Int? = null,
    val severity: String = "High"
)

data class FormInfo(
    val action: String = "",
    val method: String = "",
    val type: String = "",
    val classifications: List<String> = emptyList(),
    @SerializedName("has_csrf") val hasCsrf: Boolean = false,
    @SerializedName("csrf_protected") val csrfProtected: Boolean = false,
    @SerializedName("input_count") val inputCount: Int = 0,
    @SerializedName("parameter_count") val parameterCount: Int = 0,
    @SerializedName("risky_inputs") val riskyInputs: List<String> = emptyList(),
    @SerializedName("risky_parameters") val riskyParameters: List<RiskyParameter> = emptyList(),
    @SerializedName("source_url") val sourceUrl: String = "",
    @SerializedName("has_file_upload") val hasFileUpload: Boolean = false,
    @SerializedName("has_password") val hasPassword: Boolean = false,
    @SerializedName("security_issues") val securityIssues: List<FormSecurityIssue> = emptyList()
) {
    // Computed properties for backwards compatibility
    val effectiveHasCsrf: Boolean get() = hasCsrf || csrfProtected
    val effectiveInputCount: Int get() = if (inputCount > 0) inputCount else parameterCount
    val effectiveType: String get() = if (type.isNotEmpty()) type else classifications.firstOrNull() ?: "OTHER"
}

data class RiskyParameter(
    val name: String = "",
    val type: String = "",
    val risky: Boolean = false,
    @SerializedName("risk_category") val riskCategory: String? = null
)

data class FormSecurityIssue(
    val issue: String = "",
    val severity: String = "",
    val field: String? = null,
    val recommendation: String? = null
)

data class CookieInfo(
    val name: String = "",
    // Support both naming conventions from Python
    @SerializedName("has_httponly") val hasHttpOnly: Boolean = false,
    @SerializedName("has_secure") val hasSecure: Boolean = false,
    @SerializedName("has_samesite") val hasSameSite: Boolean = false,
    @SerializedName("samesite_value") val sameSiteValue: String? = null,
    @SerializedName("is_session") val isSession: Boolean = false,
    // Direct from Python
    val httponly: Boolean = false,
    val secure: Boolean = false,
    val samesite: String? = null,
    val path: String = "/",
    val domain: String? = null,
    @SerializedName("max_age") val maxAge: Long? = null,
    val expires: String? = null,
    val classifications: List<String> = emptyList(),
    // Issues can be either list of strings or list of CookieIssue objects  
    val issues: List<Any> = emptyList(),
    @SerializedName("issue_count") val issueCount: Int = 0,
    @SerializedName("source_url") val sourceUrl: String = ""
) {
    // Computed properties for backwards compatibility
    val effectiveHttpOnly: Boolean get() = hasHttpOnly || httponly
    val effectiveSecure: Boolean get() = hasSecure || secure
    val effectiveSameSite: Boolean get() = hasSameSite || samesite != null
    val effectiveSameSiteValue: String? get() = sameSiteValue ?: samesite
    val effectiveIsSession: Boolean get() = isSession || classifications.contains("SESSION")
    
    // Get issues as strings for display
    val issueStrings: List<String> get() {
        return issues.mapNotNull { issue ->
            when (issue) {
                is String -> issue
                is Map<*, *> -> issue["issue"]?.toString()
                else -> issue.toString()
            }
        }
    }
}

data class OsintSummary(
    @SerializedName("unique_emails") val uniqueEmails: List<String> = emptyList(),
    @SerializedName("unique_phones") val uniquePhones: List<String> = emptyList(),
    @SerializedName("social_presence") val socialPresence: Map<String, List<String>> = emptyMap(),
    @SerializedName("unique_names") val uniqueNames: List<String> = emptyList(),
    @SerializedName("pii_findings") val piiFindings: List<PiiFinding> = emptyList(),
    @SerializedName("ct_subdomains") val ctSubdomains: List<CtSubdomain> = emptyList(),
    @SerializedName("wayback_urls") val waybackUrls: List<WaybackUrl> = emptyList(),
    val counts: OsintCounts? = null
)

data class OsintCounts(
    val emails: Int = 0,
    val phones: Int = 0,
    @SerializedName("social_platforms") val socialPlatforms: Int = 0,
    val names: Int = 0,
    val pii: Int = 0,
    @SerializedName("ct_subdomains") val ctSubdomains: Int = 0,
    val wayback: Int = 0
)

data class PiiFinding(
    val type: String = "",
    val severity: String = "",
    val description: String = "",
    @SerializedName("value_masked") val valueMasked: String = "",
    val source: String = ""
)

data class CtSubdomain(
    val subdomain: String = "",
    val issuer: String? = null,
    @SerializedName("not_before") val notBefore: String? = null,
    @SerializedName("not_after") val notAfter: String? = null
)

data class WaybackUrl(
    val url: String = "",
    val timestamp: String = "",
    val status: String = "",
    @SerializedName("archive_url") val archiveUrl: String = ""
)

data class TechnologyInfo(
    val key: String = "",
    val name: String = "",
    val version: String? = null,
    val source: String = ""
)

data class Vulnerability(
    val type: String = "",
    val severity: String = "",
    val url: String = "",
    val cve: String? = null,
    val description: String? = null,
    val condition: String? = null,
    val software: String? = null
)

data class ErrorPagesResult(
    @SerializedName("error_pages") val errorPages: List<ErrorPageInfo> = emptyList(),
    @SerializedName("info_disclosure") val infoDisclosure: List<String> = emptyList()
)

data class ErrorPageInfo(
    val url: String = "",
    val status: Int = 0,
    val issue: String = "",
    val severity: String = "",
    val trigger: String = "",
    @SerializedName("reveals_server") val revealsServer: Boolean = false,
    @SerializedName("reveals_technology") val revealsTechnology: Boolean = false
)

// ============ NEW: Advanced Security Scan Data Classes ============

data class DnsReconResult(
    val domain: String = "",
    val records: Map<String, List<String>> = emptyMap(),
    @SerializedName("mx_records") val mxRecords: List<MxRecord> = emptyList(),
    @SerializedName("nameservers") val nameServers: List<String> = emptyList(),
    val summary: Map<String, Any> = emptyMap()
)

data class MxRecord(
    val host: String = "",
    val priority: Int = 0,
    val provider: String? = null
)

data class EmailSecurityResult(
    val domain: String = "",
    val spf: SpfResult? = null,
    val dmarc: DmarcResult? = null,
    val dkim: DkimResult? = null,
    val grade: String = "F",
    val score: Int = 0,
    val issues: List<SecurityIssue> = emptyList(),
    val summary: Map<String, Any> = emptyMap()
)

data class SpfResult(
    val present: Boolean = false,
    val record: String? = null,
    val valid: Boolean = false,
    val mechanisms: List<String> = emptyList(),
    val issues: List<String> = emptyList()
)

data class DmarcResult(
    val present: Boolean = false,
    val record: String? = null,
    val policy: String? = null,
    @SerializedName("subdomain_policy") val subdomainPolicy: String? = null,
    val issues: List<String> = emptyList()
)

data class DkimResult(
    val checked: Boolean = false,
    @SerializedName("selectors_found") val selectorsFound: List<String> = emptyList()
)

data class SslAnalysisResult(
    val url: String = "",
    val certificate: CertificateInfo? = null,
    @SerializedName("tls_versions") val tlsVersions: TlsVersions? = null,
    @SerializedName("ct_logs") val ctLogs: List<CtLogEntry> = emptyList(),
    @SerializedName("hsts_preload") val hstsPreload: HstsPreload? = null,
    val issues: List<SecurityIssue> = emptyList(),
    val grade: String = "F",
    val score: Int = 0,
    val summary: Map<String, Any> = emptyMap()
)

data class CertificateInfo(
    val issuer: String = "",
    val subject: String = "",
    @SerializedName("not_before") val notBefore: String = "",
    @SerializedName("not_after") val notAfter: String = "",
    @SerializedName("days_until_expiry") val daysUntilExpiry: Int = 0,
    @SerializedName("is_expired") val isExpired: Boolean = false,
    @SerializedName("san_domains") val sanDomains: List<String> = emptyList()
)

data class TlsVersions(
    @SerializedName("tls_1_0") val tls10: Boolean = false,
    @SerializedName("tls_1_1") val tls11: Boolean = false,
    @SerializedName("tls_1_2") val tls12: Boolean = false,
    @SerializedName("tls_1_3") val tls13: Boolean = false,
    @SerializedName("insecure_versions") val insecureVersions: List<String> = emptyList()
)

data class CtLogEntry(
    val issuer: String = "",
    @SerializedName("common_name") val commonName: String = "",
    @SerializedName("not_before") val notBefore: String = "",
    @SerializedName("not_after") val notAfter: String = ""
)

data class HstsPreload(
    @SerializedName("in_preload_list") val inPreloadList: Boolean = false,
    val status: String = ""
)

data class SubdomainEnumResult(
    val domain: String = "",
    val subdomains: List<DiscoveredSubdomain> = emptyList(),
    @SerializedName("total_found") val totalFound: Int = 0,
    @SerializedName("live_count") val liveCount: Int = 0,
    val sources: List<String> = emptyList(),
    val summary: Map<String, Any> = emptyMap()
)

data class DiscoveredSubdomain(
    val subdomain: String = "",
    val url: String = "",
    val live: Boolean = false,
    @SerializedName("status_code") val statusCode: Int? = null,
    val source: String = "",
    val technologies: List<String> = emptyList(),
    @SerializedName("risk_level") val riskLevel: String = ""
)

data class ApiDiscoveryResult(
    val url: String = "",
    @SerializedName("swagger_specs") val swaggerSpecs: List<SwaggerSpec> = emptyList(),
    @SerializedName("graphql_endpoints") val graphqlEndpoints: List<GraphqlEndpoint> = emptyList(),
    @SerializedName("rest_endpoints") val restEndpoints: List<RestEndpoint> = emptyList(),
    @SerializedName("websockets") val webSockets: List<String> = emptyList(),
    @SerializedName("total_endpoints") val totalEndpoints: Int = 0,
    val summary: Map<String, Any> = emptyMap()
)

data class SwaggerSpec(
    val url: String = "",
    val title: String = "",
    val version: String = "",
    @SerializedName("endpoints_count") val endpointsCount: Int = 0,
    @SerializedName("security_schemes") val securitySchemes: List<String> = emptyList()
)

data class GraphqlEndpoint(
    val url: String = "",
    @SerializedName("introspection_enabled") val introspectionEnabled: Boolean = false,
    val types: List<String> = emptyList(),
    val queries: List<String> = emptyList(),
    val mutations: List<String> = emptyList()
)

data class RestEndpoint(
    val path: String = "",
    val method: String = "",
    @SerializedName("status_code") val statusCode: Int = 0,
    val source: String = ""
)

data class ParamFuzzingResult(
    val url: String = "",
    @SerializedName("discovered_params") val discoveredParams: List<DiscoveredParam> = emptyList(),
    @SerializedName("reflected_params") val reflectedParams: List<ReflectedParam> = emptyList(),
    @SerializedName("sensitive_params") val sensitiveParams: List<String> = emptyList(),
    @SerializedName("total_tested") val totalTested: Int = 0,
    @SerializedName("total_found") val totalFound: Int = 0,
    val summary: Map<String, Any> = emptyMap()
)

data class DiscoveredParam(
    val name: String = "",
    val method: String = "",
    @SerializedName("response_diff") val responseDiff: Boolean = false,
    val reflected: Boolean = false
)

data class ReflectedParam(
    val name: String = "",
    val context: String = "",
    @SerializedName("potential_xss") val potentialXss: Boolean = false
)

data class AuthTestingResult(
    val url: String = "",
    @SerializedName("login_pages") val loginPages: List<LoginPage> = emptyList(),
    @SerializedName("rate_limiting") val rateLimiting: RateLimitingResult? = null,
    @SerializedName("account_lockout") val accountLockout: AccountLockoutResult? = null,
    @SerializedName("username_enumeration") val usernameEnumeration: UsernameEnumResult? = null,
    @SerializedName("default_credentials") val defaultCredentials: List<DefaultCredResult> = emptyList(),
    val issues: List<SecurityIssue> = emptyList(),
    val summary: Map<String, Any> = emptyMap()
)

data class LoginPage(
    val url: String = "",
    @SerializedName("form_action") val formAction: String = "",
    @SerializedName("has_captcha") val hasCaptcha: Boolean = false,
    @SerializedName("has_mfa") val hasMfa: Boolean = false,
    @SerializedName("uses_https") val usesHttps: Boolean = false
)

data class RateLimitingResult(
    val implemented: Boolean = false,
    @SerializedName("requests_before_limit") val requestsBeforeLimit: Int? = null,
    @SerializedName("lockout_duration") val lockoutDuration: Int? = null
)

data class AccountLockoutResult(
    val detected: Boolean = false,
    @SerializedName("attempts_before_lockout") val attemptsBeforeLockout: Int? = null
)

data class UsernameEnumResult(
    val vulnerable: Boolean = false,
    val evidence: String = ""
)

data class DefaultCredResult(
    @SerializedName("login_url") val loginUrl: String = "",
    val username: String = "",
    val success: Boolean = false
)

data class CloudScannerResult(
    val url: String = "",
    @SerializedName("buckets_found") val bucketsFound: List<CloudBucket> = emptyList(),
    @SerializedName("exposed_buckets") val exposedBuckets: List<ExposedBucket> = emptyList(),
    val issues: List<SecurityIssue> = emptyList(),
    val summary: Map<String, Any> = emptyMap()
)

data class CloudBucket(
    val name: String = "",
    val provider: String = "",
    val url: String = "",
    val source: String = ""
)

data class ExposedBucket(
    val name: String = "",
    val provider: String = "",
    val url: String = "",
    @SerializedName("public_access") val publicAccess: Boolean = false,
    @SerializedName("listing_enabled") val listingEnabled: Boolean = false,
    @SerializedName("sample_files") val sampleFiles: List<String> = emptyList()
)

data class SecurityHeadersResult(
    val url: String = "",
    @SerializedName("present_headers") val presentHeaders: List<HeaderInfo> = emptyList(),
    @SerializedName("missing_headers") val missingHeaders: List<MissingHeader> = emptyList(),
    @SerializedName("deprecated_headers") val deprecatedHeaders: List<DeprecatedHeader> = emptyList(),
    val grade: String = "F",
    val score: Int = 0,
    val recommendations: List<HeaderRecommendation> = emptyList(),
    val summary: Map<String, Any> = emptyMap()
)

data class HeaderInfo(
    val name: String = "",
    @SerializedName("display_name") val displayName: String = "",
    val value: String = "",
    val description: String = ""
)

data class MissingHeader(
    val name: String = "",
    @SerializedName("display_name") val displayName: String = "",
    val description: String = "",
    val weight: Int = 0
)

data class DeprecatedHeader(
    val header: String = "",
    val value: String = "",
    val reason: String = "",
    val severity: String = ""
)

data class HeaderRecommendation(
    val header: String = "",
    val value: String = "",
    val priority: String = ""
)

data class SecurityIssue(
    val severity: String = "",
    val issue: String = "",
    val recommendation: String = ""
)